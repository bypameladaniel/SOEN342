<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/TripDB.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/TripDB.java" />
              <option name="originalContent" value="import java.sql.DriverManager;&#10;import java.sql.SQLException;&#10;import java.time.DayOfWeek;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.*;&#10;&#10;public class TripDB {&#10;    java.sql.Connection dbConnection;&#10;    &#10;    public TripDB() {&#10;        try {&#10;            dbConnection = DriverManager.getConnection(&quot;jdbc:sqlite:soen342.db&quot;);&#10;            createTableIfNotExists();&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    private void createTableIfNotExists() {&#10;        String sql = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS Trip (&#10;                tripId TEXT PRIMARY KEY,&#10;                connections TEXT, -- serialized list of Connection objects (e.g., JSON)&#10;                totalFirstClassRate REAL,&#10;                totalSecondClassRate REAL,&#10;                tripDuration TEXT,&#10;                tripDurationInMinutes INTEGER,&#10;                waitTime TEXT,&#10;                waitTimeInMinutes INTEGER&#10;            );&#10;        &quot;&quot;&quot;;&#10;        try {&#10;            dbConnection.createStatement().execute(sql);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    private static boolean searchTripPolicy(Connection firstConnection, Connection secondConnection) {&#10;        boolean layoverAccepted;&#10;&#10;        LocalTime firstArrivalTime = LocalTime.parse(firstConnection.getArrivalTime().substring(0, 5));&#10;        LocalTime secondDepartureTime = LocalTime.parse(secondConnection.getDepartureTime().substring(0, 5));&#10;&#10;        LocalTime afterHoursStart = LocalTime.of(22, 0);&#10;        LocalTime afterHoursEnd = LocalTime.of(5, 0);&#10;&#10;        boolean isAfterHours = firstArrivalTime.isAfter(afterHoursStart) || firstArrivalTime.isBefore(afterHoursEnd);&#10;&#10;        int arrivalMinutes = firstArrivalTime.getHour() * 60 + firstArrivalTime.getMinute();&#10;        int departureMinutes = secondDepartureTime.getHour() * 60 + secondDepartureTime.getMinute();&#10;        int duration = departureMinutes - arrivalMinutes;&#10;&#10;        LocalDate currentDate = LocalDate.now();&#10;        DayOfWeek currentDay = currentDate.getDayOfWeek();&#10;        NextOperationDayResult departureDay = Trip.getNextOperatingDay(currentDay,&#10;                firstConnection.getDaysOfOperation());&#10;&#10;        if (!secondConnection.getDaysOfOperation().contains(departureDay.day()) || duration &lt; 0) {&#10;            NextOperationDayResult layover = Trip.getNextOperatingDay(departureDay.day(),&#10;                    secondConnection.getDaysOfOperation());&#10;            layoverAccepted = layover.waitDays() == 1 &amp;&amp; duration &lt; 0;&#10;        } else {&#10;            layoverAccepted = true;&#10;        }&#10;&#10;        if (layoverAccepted) {&#10;            if (duration &lt; 0) {&#10;                duration += 24 * 60;&#10;            }&#10;            if (isAfterHours) {&#10;                return duration &lt; 120;&#10;            } else {&#10;                return duration &lt; 240;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public static List&lt;Trip&gt; findIndirectTrips(City departureCity, City arrivalCity) {&#10;        List&lt;Trip&gt; results = new ArrayList&lt;&gt;();&#10;&#10;        if (departureCity == null || arrivalCity == null) {&#10;            return results; // no such city&#10;        }&#10;&#10;        // Explore all 1-stop and 2-stop paths&#10;        for (Connection firstLeg : departureCity.getOutgoingConnections()) {&#10;            City midCity = firstLeg.getArrivalCity();&#10;&#10;            // Direct path (1 leg = already a trip)&#10;            if (midCity.equals(arrivalCity)) {&#10;                results.add(new Trip(Arrays.asList(firstLeg)));&#10;            }&#10;&#10;            // 1-stop paths&#10;            for (Connection secondLeg : midCity.getOutgoingConnections()) {&#10;                City secondCity = secondLeg.getArrivalCity();&#10;&#10;                if (secondCity.equals(arrivalCity) &amp;&amp; searchTripPolicy(firstLeg, secondLeg)) {&#10;                    results.add(new Trip(Arrays.asList(firstLeg, secondLeg)));&#10;                }&#10;&#10;                // 2-stop paths&#10;                for (Connection thirdLeg : secondCity.getOutgoingConnections()) {&#10;                    if (thirdLeg.getArrivalCity().equals(arrivalCity) &amp;&amp; searchTripPolicy(firstLeg, secondLeg)&#10;                            &amp;&amp; searchTripPolicy(secondLeg, thirdLeg)) {&#10;                        results.add(new Trip(Arrays.asList(firstLeg, secondLeg, thirdLeg)));&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return results;&#10;    }&#10;&#10;    public static List&lt;Trip&gt; sortTrips(List&lt;Trip&gt; list, int sortBy, boolean isAscending) {&#10;        if (!list.isEmpty()) {&#10;            List&lt;Trip&gt; sortedTrips = new ArrayList&lt;&gt;(list);&#10;            sortedTrips.sort((Comparator&lt;Trip&gt;) getTripComparator(sortBy, isAscending));&#10;            return sortedTrips;&#10;        }&#10;        return list;&#10;    }&#10;&#10;    public static Comparator&lt;Trip&gt; getTripComparator(int sortBy, boolean isAscending) {&#10;        Comparator&lt;Trip&gt; comparator = switch (sortBy) {&#10;            case 1 -&gt; Comparator.comparingDouble(trip -&gt; trip.getTotalFirstClassRate());&#10;            case 2 -&gt; Comparator.comparingDouble(trip -&gt; trip.getTotalSecondClassRate());&#10;            case 3 -&gt; Comparator.comparingInt(trip -&gt; trip.getTripDurationInMinutes());&#10;            default -&gt; throw new IllegalArgumentException(&quot;Invalid sort field: &quot; + sortBy);&#10;        };&#10;        return isAscending ? comparator : comparator.reversed();&#10;    }&#10;&#10;    public static List&lt;Trip&gt; getSpecificTrip(SearchQuery searchQuery, List&lt;Trip&gt; trips) {&#10;        List&lt;Trip&gt; results = new ArrayList&lt;&gt;(trips);&#10;&#10;        LocalTime departureTimeStart = LocalTime.of(0, 0);&#10;        LocalTime departureTimeEnd = LocalTime.of(0, 0);&#10;&#10;        if (searchQuery.getDepartureTime() != null) {&#10;            departureTimeStart = LocalTime.parse(searchQuery.getDepartureTime());&#10;            departureTimeEnd = departureTimeStart.plusHours(1);&#10;        }&#10;&#10;        LocalTime arrivalTimeEnd = LocalTime.of(0, 0);&#10;        LocalTime arrivalTimeStart = LocalTime.of(0, 0);&#10;&#10;        if (searchQuery.getArrivalTime() != null) {&#10;            arrivalTimeEnd = LocalTime.parse(searchQuery.getArrivalTime().substring(0, 5));&#10;            arrivalTimeStart = arrivalTimeEnd.minusHours(1);&#10;        }&#10;&#10;        for (Trip trip : trips) {&#10;            if (searchQuery.getDepartureTime() != null) {&#10;                LocalTime tripDeparture = LocalTime.parse(trip.getConnections().get(0).getDepartureTime());&#10;                if (!(tripDeparture.isAfter(arrivalTimeStart) &amp;&amp;&#10;                        tripDeparture.isBefore(arrivalTimeEnd))) {&#10;                    results.remove(trip);&#10;                }&#10;            }&#10;&#10;            if (searchQuery.getDepartureTime() != null) {&#10;                LocalTime tripDeparture = LocalTime.parse(&#10;                        trip.getConnections().get(trip.getConnections().size() - 1).getArrivalTime().substring(0, 5));&#10;                if (!(tripDeparture.isAfter(arrivalTimeStart) &amp;&amp;&#10;                        tripDeparture.isBefore(arrivalTimeEnd))) {&#10;                    results.remove(trip);&#10;                }&#10;            }&#10;&#10;            if (searchQuery.getTrainType() != null) {&#10;                for (Connection connection : trip.getConnections()) {&#10;                    if (!searchQuery.getTrainType().equals(connection.getTrainType())) {&#10;                        results.remove(trip);&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (searchQuery.getDaysOfWeek() != null &amp;&amp;&#10;                    Collections.disjoint(&#10;                            trip.getConnections().get(0).getDaysOfOperation(),&#10;                            searchQuery.getDaysOfWeek())) {&#10;                results.remove(trip);&#10;            }&#10;&#10;            if (searchQuery.getFirstClassRate() != 0.0&#10;                    &amp;&amp; trip.getTotalFirstClassRate() != searchQuery.getFirstClassRate()) {&#10;                results.remove(trip);&#10;            }&#10;&#10;            if (searchQuery.getSecondClassRate() != 0.0&#10;                    &amp;&amp; trip.getTotalSecondClassRate() != searchQuery.getSecondClassRate()) {&#10;                results.remove(trip);&#10;            }&#10;&#10;        }&#10;&#10;        return results;&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="import java.sql.DriverManager;&#10;import java.sql.SQLException;&#10;import java.time.DayOfWeek;&#10;import java.time.LocalDate;&#10;import java.time.LocalTime;&#10;import java.util.*;&#10;&#10;public class TripDB {&#10;    java.sql.Connection dbConnection;&#10;    &#10;    public TripDB() {&#10;        try {&#10;            dbConnection = DriverManager.getConnection(&quot;jdbc:sqlite:soen342.db&quot;);&#10;            createTableIfNotExists();&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    private void createTableIfNotExists() {&#10;        String sql = &quot;&quot;&quot;&#10;            CREATE TABLE IF NOT EXISTS Trip (&#10;                tripId TEXT PRIMARY KEY,&#10;                connections TEXT, -- serialized list of Connection objects (e.g., JSON)&#10;                totalFirstClassRate REAL,&#10;                totalSecondClassRate REAL,&#10;                tripDuration TEXT,&#10;                tripDurationInMinutes INTEGER,&#10;                waitTime TEXT,&#10;                waitTimeInMinutes INTEGER&#10;            );&#10;        &quot;&quot;&quot;;&#10;        try {&#10;            dbConnection.createStatement().execute(sql);&#10;        } catch (SQLException e) {&#10;            e.printStackTrace();&#10;        }&#10;    }&#10;    &#10;    private static boolean searchTripPolicy(Connection firstConnection, Connection secondConnection) {&#10;        boolean layoverAccepted;&#10;&#10;        LocalTime firstArrivalTime = LocalTime.parse(firstConnection.getArrivalTime().substring(0, 5));&#10;        LocalTime secondDepartureTime = LocalTime.parse(secondConnection.getDepartureTime().substring(0, 5));&#10;&#10;        LocalTime afterHoursStart = LocalTime.of(22, 0);&#10;        LocalTime afterHoursEnd = LocalTime.of(5, 0);&#10;&#10;        boolean isAfterHours = firstArrivalTime.isAfter(afterHoursStart) || firstArrivalTime.isBefore(afterHoursEnd);&#10;&#10;        int arrivalMinutes = firstArrivalTime.getHour() * 60 + firstArrivalTime.getMinute();&#10;        int departureMinutes = secondDepartureTime.getHour() * 60 + secondDepartureTime.getMinute();&#10;        int duration = departureMinutes - arrivalMinutes;&#10;&#10;        LocalDate currentDate = LocalDate.now();&#10;        DayOfWeek currentDay = currentDate.getDayOfWeek();&#10;        NextOperationDayResult departureDay = Trip.getNextOperatingDay(currentDay,&#10;                firstConnection.getDaysOfOperation());&#10;&#10;        if (!secondConnection.getDaysOfOperation().contains(departureDay.day()) || duration &lt; 0) {&#10;            NextOperationDayResult layover = Trip.getNextOperatingDay(departureDay.day(),&#10;                    secondConnection.getDaysOfOperation());&#10;            layoverAccepted = layover.waitDays() == 1 &amp;&amp; duration &lt; 0;&#10;        } else {&#10;            layoverAccepted = true;&#10;        }&#10;&#10;        if (layoverAccepted) {&#10;            if (duration &lt; 0) {&#10;                duration += 24 * 60;&#10;            }&#10;            if (isAfterHours) {&#10;                return duration &lt; 120;&#10;            } else {&#10;                return duration &lt; 240;&#10;            }&#10;        }&#10;        return false;&#10;    }&#10;&#10;    public static List&lt;Trip&gt; findIndirectTrips(City departureCity, City arrivalCity) {&#10;        List&lt;Trip&gt; results = new ArrayList&lt;&gt;();&#10;&#10;        if (departureCity == null || arrivalCity == null) {&#10;            return results; // no such city&#10;        }&#10;&#10;        // Explore all 1-stop and 2-stop paths&#10;        for (Connection firstLeg : departureCity.getOutgoingConnections()) {&#10;            City midCity = firstLeg.getArrivalCity();&#10;&#10;            // Direct path (1 leg = already a trip)&#10;            if (midCity.equals(arrivalCity)) {&#10;                results.add(new Trip(Arrays.asList(firstLeg)));&#10;            }&#10;&#10;            // 1-stop paths&#10;            for (Connection secondLeg : midCity.getOutgoingConnections()) {&#10;                City secondCity = secondLeg.getArrivalCity();&#10;&#10;                if (secondCity.equals(arrivalCity) &amp;&amp; searchTripPolicy(firstLeg, secondLeg)) {&#10;                    results.add(new Trip(Arrays.asList(firstLeg, secondLeg)));&#10;                }&#10;&#10;                // 2-stop paths&#10;                for (Connection thirdLeg : secondCity.getOutgoingConnections()) {&#10;                    if (thirdLeg.getArrivalCity().equals(arrivalCity) &amp;&amp; searchTripPolicy(firstLeg, secondLeg)&#10;                            &amp;&amp; searchTripPolicy(secondLeg, thirdLeg)) {&#10;                        results.add(new Trip(Arrays.asList(firstLeg, secondLeg, thirdLeg)));&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        return results;&#10;    }&#10;&#10;    public static List&lt;Trip&gt; sortTrips(List&lt;Trip&gt; list, int sortBy, boolean isAscending) {&#10;        if (!list.isEmpty()) {&#10;            List&lt;Trip&gt; sortedTrips = new ArrayList&lt;&gt;(list);&#10;            sortedTrips.sort((Comparator&lt;Trip&gt;) getTripComparator(sortBy, isAscending));&#10;            return sortedTrips;&#10;        }&#10;        return list;&#10;    }&#10;&#10;    public static Comparator&lt;Trip&gt; getTripComparator(int sortBy, boolean isAscending) {&#10;        Comparator&lt;Trip&gt; comparator = switch (sortBy) {&#10;            case 1 -&gt; Comparator.comparingDouble(trip -&gt; trip.getTotalFirstClassRate());&#10;            case 2 -&gt; Comparator.comparingDouble(trip -&gt; trip.getTotalSecondClassRate());&#10;            case 3 -&gt; Comparator.comparingInt(trip -&gt; trip.getTripDurationInMinutes());&#10;            default -&gt; throw new IllegalArgumentException(&quot;Invalid sort field: &quot; + sortBy);&#10;        };&#10;        return isAscending ? comparator : comparator.reversed();&#10;    }&#10;&#10;    public static List&lt;Trip&gt; getSpecificTrip(SearchQuery searchQuery, List&lt;Trip&gt; trips) {&#10;        List&lt;Trip&gt; results = new ArrayList&lt;&gt;(trips);&#10;&#10;        LocalTime departureTimeStart = LocalTime.of(0, 0);&#10;        LocalTime departureTimeEnd = LocalTime.of(0, 0);&#10;&#10;        if (searchQuery.getDepartureTime() != null) {&#10;            departureTimeStart = LocalTime.parse(searchQuery.getDepartureTime());&#10;            departureTimeEnd = departureTimeStart.plusHours(1);&#10;        }&#10;&#10;        LocalTime arrivalTimeEnd = LocalTime.of(0, 0);&#10;        LocalTime arrivalTimeStart = LocalTime.of(0, 0);&#10;&#10;        if (searchQuery.getArrivalTime() != null) {&#10;            arrivalTimeEnd = LocalTime.parse(searchQuery.getArrivalTime().substring(0, 5));&#10;            arrivalTimeStart = arrivalTimeEnd.minusHours(1);&#10;        }&#10;&#10;        for (Trip trip : trips) {&#10;            if (searchQuery.getDepartureTime() != null) {&#10;                LocalTime tripDeparture = LocalTime.parse(trip.getConnections().get(0).getDepartureTime());&#10;                if (!(tripDeparture.isAfter(arrivalTimeStart) &amp;&amp;&#10;                        tripDeparture.isBefore(arrivalTimeEnd))) {&#10;                    results.remove(trip);&#10;                }&#10;            }&#10;&#10;            if (searchQuery.getDepartureTime() != null) {&#10;                LocalTime tripDeparture = LocalTime.parse(&#10;                        trip.getConnections().get(trip.getConnections().size() - 1).getArrivalTime().substring(0, 5));&#10;                if (!(tripDeparture.isAfter(arrivalTimeStart) &amp;&amp;&#10;                        tripDeparture.isBefore(arrivalTimeEnd))) {&#10;                    results.remove(trip);&#10;                }&#10;            }&#10;&#10;            if (searchQuery.getTrainType() != null) {&#10;                for (Connection connection : trip.getConnections()) {&#10;                    if (!searchQuery.getTrainType().equals(connection.getTrainType())) {&#10;                        results.remove(trip);&#10;                    }&#10;                }&#10;            }&#10;&#10;            if (searchQuery.getDaysOfWeek() != null &amp;&amp;&#10;                    Collections.disjoint(&#10;                            trip.getConnections().get(0).getDaysOfOperation(),&#10;                            searchQuery.getDaysOfWeek())) {&#10;                results.remove(trip);&#10;            }&#10;&#10;            if (searchQuery.getFirstClassRate() != 0.0&#10;                    &amp;&amp; trip.getTotalFirstClassRate() != searchQuery.getFirstClassRate()) {&#10;                results.remove(trip);&#10;            }&#10;&#10;            if (searchQuery.getSecondClassRate() != 0.0&#10;                    &amp;&amp; trip.getTotalSecondClassRate() != searchQuery.getSecondClassRate()) {&#10;                results.remove(trip);&#10;            }&#10;&#10;        }&#10;&#10;        return results;&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>